%Evolutionary Optimization 1.0
%
tic
% %D = [1,1,1,1,1,1;
%      1,0,1,1,0,1;
%      0,0,0,0,0,1;
%      1,0,1,0,1,0;
%      0,1,1,0,0,0;
%      1,0,0,1,1,0];


D = randi([0 1], 8,8)

%Collect information about data
[numRows, numCols] = size(D);
perm = [1:numRows];
maxP = factorial(numRows);
n=length(D);
sizePopulation = 10;
maxk = numRows*numRows - numRows;

%First: Generate a population (i.e. generate rankings)
%NOTE: There are numRows! possible rankings
%Write a for loop using randperm for get a more random initial population
firstGen = [];
for i = 1:sizePopulation
    perm = randperm(numRows);
    firstGen = [firstGen perm'];
end
firstGen;

%Second: Calculate fitness
%As of now, fitness = k
%Need to find a way to keep track of permuatations and their fitness
firstGenFit = [];
%op=[]
 for i = 1:length(firstGen)
    % perm=nextperm(perm,i);
     perm = firstGen(:,i);
     A = D(perm, perm);
     fitness=nnz(tril(A))+(numRows*(numRows-1)/2 - nnz(triu(A,1)));
     firstGenFit = [firstGenFit; fitness];
     %op = [op; i, fitness]
 end
%B = [sortrows(op, 2)]

iteration = 1;
kArray = [];
k = min(firstGenFit)+1;
previousk =min(firstGenFit)%10^10;
% while k < previousk || iteration <10
%   if iteration == 1
%     previousk = 100000000;
%   else
%     previousk = k;
%   end
%Third: Selection
%Probability of choosing a member is proportional to its fitness
  matingArray = [];
  for i= 1:sizePopulation
    [mate1, mate2] = selection(firstGenFit,firstGen,sizePopulation);
    matingArray = [matingArray mate1 mate2];
  end
   offspringArray = [];
  flipOffspringArray = []; 
while iteration <1000 %& k>previousk
    
    
%   if iteration == 1
%     previousk = 100000000;
%   else
%     previousk = k;
%   end
%Fourth: Mating

% Spencer Method
  for i = 1:length(matingArray)/5+1
    offspring = leftTieBreakMate(matingArray(:,i),matingArray(:,length(matingArray)/2+i));
    offspringArray = [offspringArray offspring];
  end

%Katelynn Method  
  for i = length(matingArray)/5:length(matingArray)/2-2
      mate1 = matingArray(:,2*i+1);
      mate2 = matingArray(:,2*i+2);
      offspring = katelynnMethod(mate1,mate2);
      offspringArray = [offspringArray offspring];
  end
  for i=1:sizePopulation
    flipOffspring = flipMutate(offspringArray(:,i));
    flipOffspringArray = [flipOffspringArray, flipOffspring];
  end 
    
%Fifth: Fitness of offspring 
  newFitArray = [];
  for i = 1:length(offspringArray)
      R = D(offspringArray(i),offspringArray(i));
      newFit =nnz(tril(R))+(numRows*(numRows-1)/2 - nnz(triu(R,1)));
      newFitArray = [newFitArray newFit];
  end
  flipNewFitArray = [];
  for i = 1:length(flipOffspringArray)
      O = D(flipOffspringArray(i),flipOffspringArray(i));
      flipNewFit =nnz(tril(O))+(numRows*(numRows-1)/2 - nnz(triu(O,1)));
      flipNewFitArray = [flipNewFitArray flipNewFit];
  end  
  
  matingArrayFit = [newFitArray,flipNewFitArray];

  matingArray = [offspringArray, flipOffspringArray];
[matingArrayFit,index] = sort(matingArrayFit);
matingArray = matingArray(:,index);
matingArray = matingArray(:,1:sizePopulation);
matingArrayFit = matingArrayFit(1,1:sizePopulation);
k = min(matingArrayFit)
%   matingArray = matingArray(:,randperm(size(matingArray,2)));
%   firstGenFit = newFitArray';
%firstGen = offspringArray(:,randperm(size(offspringArray,2)));
  iteration = iteration + 1;
end

% 
% while k < previousk
% iteration = 1;
% kArray = [];
% kmin = min(firstGenFit)
% newk =10^10;
% while  kmin<newk 
%      matingArray = [];
%   for i= 1:sizePopulation
%     [mate1, mate2] = selection(firstGenFit,firstGen,sizePopulation);
%     matingArray = [matingArray mate1 mate2];
%   end


% while k<previousk || iteration <10
%     offspring = 
    
% flip = flipMutate(offspringArray(:,1))
% flipMatrix = D(flip,flip);
% flipOffspringFit =nnz(tril(flipMatrix))+(numRows*(numRows-1)/2 - nnz(triu(flipMatrix,1)))
% iteration

toc
